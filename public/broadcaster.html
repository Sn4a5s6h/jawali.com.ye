<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Broadcaster — Camera & Mic</title>
  <style>
    body { font-family: Arial, sans-serif; text-align:center; padding:20px; background:#f4f6f8; }
    video { width: 640px; max-width:100%; border-radius:8px; background:#000; }
    .info { margin:8px 0; }
    input { padding:6px; }
  </style>
</head>
<body>
  <h2>Broadcaster — افتح الكاميرا والمايكروفون تلقائيًا</h2>
  <p class="info">غرفة ثابتة: <strong id="roomLabel">room1</strong></p>
  <input id="roomId" value="room1">

  <div style="margin-top:12px;">
    <video id="localVideo" autoplay muted playsinline></video>
  </div>

  <p style="margin-top:12px;">شارك رابط المشاهدة بهذا الشكل: <code>/viewer.html?room=room1</code></p>

  <script src="/socket.io/socket.io.js"></script>
  <script>
  (async function(){
    const socket = io();
    let pcMap = new Map(); // watcherId -> RTCPeerConnection
    let localStream = null;
    const localVideo = document.getElementById('localVideo');
    const roomInput = document.getElementById('roomId');
    const roomLabel = document.getElementById('roomLabel');

    function updateRoomLabel(){ roomLabel.textContent = roomInput.value || 'room1'; }
    roomInput.addEventListener('input', updateRoomLabel);
    updateRoomLabel();

    // بدء البث مباشرة
    async function startBroadcast() {
      const roomID = roomInput.value || 'room1';
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        localVideo.srcObject = localStream;
        socket.emit('broadcaster', roomID);
        console.log('Broadcasting in room', roomID);
      } catch(err) {
        console.error('Cannot access camera/microphone:', err);
        alert('Please allow camera/microphone access.');
      }
    }

    startBroadcast();

    // استقبال المشاهدين
    socket.on('watcher', async ({ watcherId }) => {
      if (!localStream) return socket.emit('no-broadcaster', { watcherId });
      const pc = new RTCPeerConnection();
      pcMap.set(watcherId, pc);
      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      pc.onicecandidate = e => { if(e.candidate) socket.emit('candidate', { targetId: watcherId, candidate: e.candidate }); };
      const offer = await pc.createOffer();
      await pc.setLocalDescription(offer);
      socket.emit('offer', { watcherId, sdp: pc.localDescription });
      pc.onconnectionstatechange = () => {
        if(['failed','closed','disconnected'].includes(pc.connectionState)) {
          pc.close(); pcMap.delete(watcherId);
        }
      };
    });

    socket.on('answer', ({ from, sdp }) => {
      const pc = pcMap.get(from);
      if(pc) pc.setRemoteDescription(new RTCSessionDescription(sdp)).catch(console.error);
    });
    socket.on('candidate', ({ from, candidate }) => {
      const pc = pcMap.get(from);
      if(pc && candidate) pc.addIceCandidate(new RTCIceCandidate(candidate)).catch(console.error);
    });
  })();
  </script>
</body>
</html>
